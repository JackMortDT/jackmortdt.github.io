<!doctype html><html lang=es dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Ballet Binario: Haciendo Juegos de Patrones con Elixir | Jack Blog</title><meta name=keywords content="elixir,pattern matching"><meta name=description content="Binary pattern matching"><meta name=author content="JackMortDT"><link rel=canonical href=https://jackmortdt.github.io/es/posts/binary_ballet_pattern_matching_with_elixir/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=es href=https://jackmortdt.github.io/es/posts/binary_ballet_pattern_matching_with_elixir/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Ballet Binario: Haciendo Juegos de Patrones con Elixir"><meta property="og:description" content="Binary pattern matching"><meta property="og:type" content="article"><meta property="og:url" content="https://jackmortdt.github.io/es/posts/binary_ballet_pattern_matching_with_elixir/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-28T17:22:33-06:00"><meta property="article:modified_time" content="2023-08-28T17:22:33-06:00"><meta property="og:site_name" content="Jack Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ballet Binario: Haciendo Juegos de Patrones con Elixir"><meta name=twitter:description content="Binary pattern matching"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jackmortdt.github.io/es/posts/"},{"@type":"ListItem","position":2,"name":"Ballet Binario: Haciendo Juegos de Patrones con Elixir","item":"https://jackmortdt.github.io/es/posts/binary_ballet_pattern_matching_with_elixir/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Ballet Binario: Haciendo Juegos de Patrones con Elixir","name":"Ballet Binario: Haciendo Juegos de Patrones con Elixir","description":"Binary pattern matching","keywords":["elixir","pattern matching"],"articleBody":"El pattern matching es un concepto fundamental en Elixir y en muchos lenguajes funcionales. En Elixir, se refiere a la capacidad de comparar y desestructurar datos en base a su forma y contenido. Permite realizar acciones basadas en las caracteristicas específicas de los datos.\nEn lugar de usar condicionales tradicionales como if o switch para verificar condiciones, en Elixir puedes utilizar el pattern matching para manejar diferentes casos directamente en las expresiones. Aquí un ejemplo:\niex\u003e {a, b, c} = {1, 2, 3} {1, 2, 3} iex\u003e a 1 iex\u003e b 2 iex\u003e c 3 Con este ejemplo, el código utiliza el pattern matching para comparar una tupla {1, 2, 3} con valores diferentes en un tupla de variables, si por alguna razón el patrón no coincide nos arrojará un error\niex\u003e {a, b, c, d} = {1, 2, 3} ** (MatchError) no match of right hand side value: {1, 2, 3} O podemos tener algo un poco más complejo como hacer match de diferentes valores de una lista\niex\u003e [a, b, c] = [1, [2, 3], %{hola: \"adios\"}] [1, [2, 3], %{hola: \"adios\"}] iex\u003e a 1 iex\u003e b [2, 3] iex\u003e c %{hola: \"adios\"} En este caso vamos a ir por un tema un poco más complejo, pero igual de útil en Elixir, el pattern matching de binarios.\nEl pattern matching de binarios en Elixir se refiere a la capacidad para descomponer y analizar binarios(secuencias de bytes) utilizando patrones específicos. Esto es especialmente útil cuando trabajas con datos binarios, como archivos, protocolos de red y formatos de datos estructurados.\nEn elixir se puede usar el pattern matching de binarios en combinación con el operador \u003c\u003c\u003e\u003e para especificar patrones de descomposición en binarios. Aquí hay un ejemplo básico:\niex\u003e \u003c\u003ca::8, b::8, c::8, d::8\u003e\u003e = \"Hola\" \"Hola\" iex\u003e a 72 iex\u003e b 111 iex\u003e c 108 iex\u003e d 97 Aquí hay 2 cosas interesantes, la primera es porque ponemos un 8 después de cada variable que tenemos, esto se refiere a la cantidad de bits que se deben capturar para cada variable. En este caso, estamos capturando 8 bits para cada una de las variables, lo que equivale a un byte.\nEn la mayoría de los sistemas informáticos, un byte consta de 8 bits. Cada carácter en el binario “Hola” se almacena en 1 byte, ya que los caracteres ASCII se ajustan a un byte.\nPero… por qué en lugar de arrojarnos la letra nos arroja números? Esto se debe a la forma en que los caracteres se almacenan en binarios en la mayoría de los sistemas informáticos modernos. Los números que estás obteniendo son los valores de los códigos ASCII de los caracteres en la cadena “Hola”.\nEn la tabla ASCII, cada carácter se representa mediante un número. Cuando descompones un binario en Elixir, estás obteniendo los valores numéricos de los caracteres en lugar de los caracteres en sí.\n“H” en ASCII es 72\n“o” en ASCII es 111\n“l” en ASCII es 108\n“a” en ASCII es 97\nSi deseas obtener los caracteres originales en lugar de los valores numéricos, puedes usar \u003c\u003c\u003e\u003e para convertir los números de ASCII en caracteres:\niex\u003e \u003c\u003c72\u003e\u003e \"H\" iex\u003e \u003c\u003c111\u003e\u003e \"o\" iex\u003e \u003c\u003c108\u003e\u003e \"c\" iex\u003e \u003c\u003c97\u003e\u003e \"a\" Esto nos dará los caractéres reales en lugar de los valoress numéricos\n","wordCount":"546","inLanguage":"es","datePublished":"2023-08-28T17:22:33-06:00","dateModified":"2023-08-28T17:22:33-06:00","author":{"@type":"Person","name":"JackMortDT"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jackmortdt.github.io/es/posts/binary_ballet_pattern_matching_with_elixir/"},"publisher":{"@type":"Organization","name":"Jack Blog","logo":{"@type":"ImageObject","url":"https://jackmortdt.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackmortdt.github.io/es/ accesskey=h title="Home (Alt + H)"><img src=https://jackmortdt.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jackmortdt.github.io/ title=English aria-label=:en:>En</a></li></ul></div></div><ul id=menu><li><a href=https://jackmortdt.github.io/es/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://jackmortdt.github.io/es/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jackmortdt.github.io/es/>Inicio</a>&nbsp;»&nbsp;<a href=https://jackmortdt.github.io/es/posts/>Posts</a></div><h1 class=post-title>Ballet Binario: Haciendo Juegos de Patrones con Elixir</h1><div class=post-description>Binary pattern matching</div><div class=post-meta><span title='2023-08-28 17:22:33 -0600 CST'>agosto 28, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;546 palabras&nbsp;·&nbsp;JackMortDT&nbsp;|&nbsp;<a href=https://github.com/JackMortDT/JackBlog/tree/master/content/posts/binary_ballet_pattern_matching_with_elixir.es.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>El pattern matching es un concepto fundamental en Elixir y en muchos lenguajes funcionales. En Elixir, se refiere a la capacidad de comparar y desestructurar datos en base a su forma y contenido. Permite realizar acciones basadas en las caracteristicas específicas de los datos.</p><p>En lugar de usar condicionales tradicionales como <code>if</code> o <code>switch</code> para verificar condiciones, en Elixir puedes utilizar el pattern matching para manejar diferentes casos directamente en las expresiones. Aquí un ejemplo:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>{</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>}</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=mi>3</span>
</span></span></code></pre></div><p>Con este ejemplo, el código utiliza el pattern matching para comparar una tupla <code>{1, 2, 3}</code> con valores diferentes en un tupla de variables, si por alguna razón el patrón no coincide nos arrojará un error</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>{</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>}</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>**</span> <span class=p>(</span><span class=nc>MatchError</span><span class=p>)</span> <span class=n>no</span> <span class=n>match</span> <span class=n>of</span> <span class=n>right</span> <span class=n>hand</span> <span class=n>side</span> <span class=ss>value</span><span class=p>:</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
</span></span></code></pre></div><p>O podemos tener algo un poco más complejo como hacer match de diferentes valores de una lista</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>[</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>%{</span><span class=ss>hola</span><span class=p>:</span> <span class=s2>&#34;adios&#34;</span><span class=p>}]</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>%{</span><span class=ss>hola</span><span class=p>:</span> <span class=s2>&#34;adios&#34;</span><span class=p>}]</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=p>%{</span><span class=ss>hola</span><span class=p>:</span> <span class=s2>&#34;adios&#34;</span><span class=p>}</span>
</span></span></code></pre></div><p>En este caso vamos a ir por un tema un poco más complejo, pero igual de útil en Elixir, el pattern matching de binarios.</p><p>El pattern matching de binarios en Elixir se refiere a la capacidad para descomponer y analizar binarios(secuencias de bytes) utilizando patrones específicos. Esto es especialmente útil cuando trabajas con datos binarios, como archivos, protocolos de red y formatos de datos estructurados.</p><p>En elixir se puede usar el pattern matching de binarios en combinación con el operador <code>&lt;&lt;>></code> para especificar patrones de descomposición en binarios. Aquí hay un ejemplo básico:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>&lt;&lt;</span><span class=n>a</span><span class=o>::</span><span class=mi>8</span><span class=p>,</span> <span class=n>b</span><span class=o>::</span><span class=mi>8</span><span class=p>,</span> <span class=n>c</span><span class=o>::</span><span class=mi>8</span><span class=p>,</span> <span class=n>d</span><span class=o>::</span><span class=mi>8</span><span class=p>&gt;&gt;</span> <span class=o>=</span> <span class=s2>&#34;Hola&#34;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;Hola&#34;</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>a</span>
</span></span><span class=line><span class=cl><span class=mi>72</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>b</span>
</span></span><span class=line><span class=cl><span class=mi>111</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>c</span>
</span></span><span class=line><span class=cl><span class=mi>108</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=n>d</span>
</span></span><span class=line><span class=cl><span class=mi>97</span>
</span></span></code></pre></div><p>Aquí hay 2 cosas interesantes, la primera es porque ponemos un 8 después de cada variable que tenemos, esto se refiere a la cantidad de bits que se deben capturar para cada variable. En este caso, estamos capturando 8 bits para cada una de las variables, lo que equivale a un byte.</p><p>En la mayoría de los sistemas informáticos, un byte consta de 8 bits. Cada carácter en el binario &ldquo;Hola&rdquo; se almacena en 1 byte, ya que los caracteres ASCII se ajustan a un byte.</p><p>Pero&mldr; por qué en lugar de arrojarnos la letra nos arroja números?
Esto se debe a la forma en que los caracteres se almacenan en binarios en la mayoría de los sistemas informáticos modernos. Los números que estás obteniendo son los valores de los códigos ASCII de los caracteres en la cadena &ldquo;Hola&rdquo;.</p><p>En la tabla ASCII, cada carácter se representa mediante un número. Cuando descompones un binario en Elixir, estás obteniendo los valores numéricos de los caracteres en lugar de los caracteres en sí.</p><blockquote><p>&ldquo;H&rdquo; en ASCII es 72</p><p>&ldquo;o&rdquo; en ASCII es 111</p><p>&ldquo;l&rdquo; en ASCII es 108</p><p>&ldquo;a&rdquo; en ASCII es 97</p></blockquote><p>Si deseas obtener los caracteres originales en lugar de los valores numéricos, puedes usar <code>&lt;&lt;>></code> para convertir los números de ASCII en caracteres:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-elixir data-lang=elixir><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>&lt;&lt;</span><span class=mi>72</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;H&#34;</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>&lt;&lt;</span><span class=mi>111</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;o&#34;</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>&lt;&lt;</span><span class=mi>108</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;c&#34;</span>
</span></span><span class=line><span class=cl><span class=n>iex</span><span class=o>&gt;</span> <span class=p>&lt;&lt;</span><span class=mi>97</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=s2>&#34;a&#34;</span>
</span></span></code></pre></div><p>Esto nos dará los caractéres reales en lugar de los valoress numéricos</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jackmortdt.github.io/es/tags/elixir/>elixir</a></li><li><a href=https://jackmortdt.github.io/es/tags/pattern-matching/>pattern matching</a></li></ul><nav class=paginav><a class=next href=https://jackmortdt.github.io/es/posts/navigating_the_labyrinth_of_version_control/><span class=title>Siguiente »</span><br><span>Git: Travesía por un laberinto de versiones</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Ballet Binario: Haciendo Juegos de Patrones con Elixir on whatsapp" href="https://api.whatsapp.com/send?text=Ballet%20Binario%3a%20Haciendo%20Juegos%20de%20Patrones%20con%20Elixir%20-%20https%3a%2f%2fjackmortdt.github.io%2fes%2fposts%2fbinary_ballet_pattern_matching_with_elixir%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Ballet Binario: Haciendo Juegos de Patrones con Elixir on telegram" href="https://telegram.me/share/url?text=Ballet%20Binario%3a%20Haciendo%20Juegos%20de%20Patrones%20con%20Elixir&amp;url=https%3a%2f%2fjackmortdt.github.io%2fes%2fposts%2fbinary_ballet_pattern_matching_with_elixir%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jackmortdt.github.io/es/>Jack Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>